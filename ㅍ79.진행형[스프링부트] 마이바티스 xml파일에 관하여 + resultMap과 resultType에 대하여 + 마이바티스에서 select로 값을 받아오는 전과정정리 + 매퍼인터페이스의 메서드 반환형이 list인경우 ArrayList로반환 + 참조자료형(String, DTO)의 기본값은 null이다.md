.
.
.
0-1.xml파일의 선언부와 dtd명시에 대해 알아보겠다.
    (1).xml파일의 선언부
        <?xml version="버전" encoding="인코딩방식" standalone="yes 혹은 no"?>
        와 같은 형태로 선언부를 쓴다. 
            {1}.여기에서 버전에는 1.0이나 1.1을 쓸 수 있는데, 현재 xml의
                권고안의 버전은 1.0이므로 1.0을쓴다고한다. 다른 웹사이트나 참조문헌에도 1.0을썻다.
                [참조문헌 : 스프링부트 시작하기 초록책 69pg]   
                [참조링크 : https://sjh836.tistory.com/118]   
                [참조링크 : https://yayongi.tistory.com/entry/XML-%EC%84%A0%EC%96%B82] / xml 권고안의 버전은 1.0
            {2}.인코딩방식에 대한 얘기다. 여기서 encoding의 값을 따로 지정해주지 않으면
                기본값이 UTF-8로 지정이된다. 이 encoding속성의 의미는 이 xml문서가 어떤 언어로 작성
                되었는지를 알려주는 속성이다.
                [참조링크 : https://live8.tistory.com/7]   
                +
                이것의 의미는, 내 생각에 아래 링크를 보면, xml파일도 파일을 저장할때 저장방식이 UTF-8이냐,
                아니면 euc_kr로 지정하여 저장할 수 있는데, 이는 해당 xml파일을 어떠한 문자 코드로 저장하느냐 인것같다.
                또한, 이를 브라우저나 아니면 다른데서 해석할때 어떠한 문자코드로 해석하느냐의 기준은 선언부의 인코딩방식에
                들어가는 값인것같다. 그렇기에 아래 참조링크를 보면, 이 선언부와 저장할때의 문자코드가 다르면 언어가 깨질 수도
                있는것같다. 또한, UTF-8이라하면 이 xml파일에서는 이모지도 모두 포함하는것이니 이 부분에 대해서는 신경쓰지
                않아도 될 것 같다.
                그리고 이 부분에 대해 다시 볼 필요가 있다면 그때가서 다시 봐보도록 하자.
                [참조링크 : http://www.devkuma.com/books/pages/1220]
                +
                또한, 인텔리제이 프로젝트에서 xml파일을 선택해서 보면, 문자코드 저장방식이 UTF-8이고 이를
                다른 파일들과는 다르게 바꿀수 없게 클릭이 안되는거로 되있다. 이 부분도 나중에 문제일시 다시보도록 하자.
                [직접해봄]
            {3}.standalone에 관한 얘기다. 작성된 XML 문서를 XML 파서가 해석할 때 외부 DTD 문서를 참고해야 된다는 것을 
                XML 파서에게 알려주는 목적으로 XML 선언의 standalone 속성을 사용하게 된다. 속성값이 'no'이면 XML 파서로 
                하여금 외부 문서를 참고해서 XML 문서를 해석하라는 뜻이고, 'yes' 이면 XML 파서가 해당 XML 문서를 해석할 때 
                외부 문서를 참고할 필요가 없다는 뜻이다.
                [참조링크 : https://yayongi.tistory.com/entry/XML-%EC%84%A0%EC%96%B82] 
                +
                이상하게 외부문서를 참고해서 XML문서를 해석하는 방식인가 보다, 아래 글에보면 DTD을 명시할텐데, 이 방식은   
                XML 문서를 해석할 때 외부 문서를 참고하는 방식인가 보다. 또한 아래 참조링크와 참조문헌에 봐도 아예 명시를
                안해줘서 기본값을 쓰거나 no를 써준다.(standalone명시 안할시에 기본값은 no이다.) 보통 standalone 속성을 생략하는 것이 보통으로
                생략되었을 경우 기본값 no가 적용된다.
                [참조링크 : https://mybatis.org/mybatis-3/ko/getting-started.html] / standalone 명시x
                [참조문헌 : 스프링부트 시작하기 초록책 69pg] / standalone 명시x
                [참조링크 : https://yayongi.tistory.com/entry/XML-%EC%84%A0%EC%96%B82] / standalone기본값
                [참조링크 : http://ehpub.co.kr/tag/xml-%EC%84%A0%EC%96%B8%EB%B6%80/] / standalone기본값
    (2).DTD명시
        {1}.마이바티스에서는 이렇게 사용한다.
            <!DOCTYPE mapper
              PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
              "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
            [참조링크 : https://xmlns.tistory.com/4]   
            [참조링크 : https://repacat.tistory.com/26]   
            [참조링크 : https://mybatis.org/mybatis-3/ko/getting-started.html]   
            [참조문헌 : 스프링부트 시작하기 69pg]
            +
            추가로 내가, 지금 셀럽마인 임시 프로젝트에 build.gradle에 implementation('org.mybatis.spring.boot:mybatis-spring-boot-starter:2.1.3')
            와 같이 작성하였고, 마이바티스 버전은 이때 3.5.5버전이 였다. 아래 참조링크에 보면 2020년 3월 제일 최신이 3.5.4이였고 그걸 적용할때도
            위와 똑같은 DTD명시문을 적어줬다. 문제가 될시에 다시 보도록 하자.
            [참조링크 : https://kimkh0096.tistory.com/entry/01-MyBatis-1-%EA%B0%9C%EC%9A%94-%EB%B0%8F-%EC%84%A4%EC%B9%98]
        {2}.xml파일은 존재 자체가 서로 다른 주체간에 정보를 전달하는게 목표다. 그렇기 때문에 작성자와 그것을 읽는 자간 서로
            이해할 수 있도록 작성 방법이 미리 정의되어 있어야 한다. 그것을 정해놓은 스펙 문서를 DTD라 하고, xml파일의
            선언부 다음으로 가장 윗 부분에 명시하여 해당 xml 문서가 어떤 스펙으로 작성되어 있는지를 알린다.
            즉, 정리해서 이해하자면, 해당 xml문서가 어떠한 작성 방법으로 작성되어있는지를 알려주고, 그러한 방법으로 해석할 수 있게하는것같다.
            [참조링크 : https://repacat.tistory.com/26]   
            [참조링크 : http://www.tcpschool.com/xml/xml_dtd_intro]   
.
.
.
0-2.<mapper>요소에 대해 알아보겠다.
    사용은 <mapper namespace="경로">의 형태로 사용한다. 또한, 이 경로에는 해당 매퍼 인터페이스의
    패키지 경로와 인터페이스명을 포함한 전체 경로를 적어주어야 한다. 경로 적는란에 다시 볼 필요가 있으면 나중에
    다시 봐보도록 하자. 그냥 파일명만 쓰는 곳도 있음. 근데 아래보니 패키지 경로안써주니 오류남
    [직접해봄] / 패키지 경로안써주니 오류나타남
    [참조링크 : https://bigstupid.tistory.com/23]   
    [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]   
    [참조문헌 : 스프링부트 시작하기 초록책 69pg]   
    (1).이 <mapper>의 기능과 namespace의 역활에 대해 설명하겠다.
        이 해당 xml파일에 <mapper>는 sql쿼리문을 묶는 역활을 함과 동시에, <mapper>안에 적은 sql 쿼리문을
        실제로 마이바티스로 작동할 수 있게 해주는것 같다. namespace는 어느 매퍼 인터페이스와 매칭되는지를 
        지정해준다.그래서 해당 xml파일에 작성하는 모든 sql쿼리문은 <mapper>안에 적어야 한다고 한다.
        [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]   
        [직접해봄] 
    (2).한 개의 xml파일에 <mapper> 요소가 두개 이상 있을 수 없다. 
        오류가 난다고 한다. 즉, 하나의 xml 매퍼 파일에는 단 하나의 <mapper>
        태그만이 존재할 수 있다.
        [참조링크 : https://okky.kr/article/686087]   
        [참조링크 : https://heewon26.tistory.com/7]      
    (3).@Mapper 인터페이스는 모두가 제각각인 이름의 인터페이스를 만들 수 있는것처럼, xml 매퍼파일도 서로다른 xml파일에
        동일한 namespace는 만들 수 없다. 동일한 namespace가 2개일경우 오류가 난다고 한다. 또한, 위에서 본것처럼
        한 xml 매퍼파일에는 <mapper>를 두번이상 쓸 수 없으니, 하나의 매퍼 인터페이스는 하나의 xml 매퍼파일만
        갖을 수 있는거다.
        [참조링크 : https://seungjenote.tistory.com/entry/Spring-Mybatis-%EC%97%90%EB%9F%AC-5%EA%B0%80%EC%A7%80%EB%A7%8C-%EC%95%8C%EB%A9%B4-%ED%95%B4%EA%B2%B0]    
        [참조링크 : https://datajoy.tistory.com/135]
.
.
.
0-3.아래의 공통부분에 대한 내용
    (1).보니까, 주석처리는 <!-- -->로 하는데, 이 cdata안에서는 주석이 사용이안된다.
        @@@@@@@@@@@@@@@@@@@@@@@
    (2).매퍼 인터페이스를 구현한 클래스의 메서드를 실행시켰을때, 파라미터의 여부와 그에 따른, sqlSession.~()
        메서드의 실행과정 그리고, xml파일의 해석과 마이바티스식 분석 그리고 데이터베이스에 쿼리문을 보내기 까지의 전과정을 설명하겠다.
            1.우선, 처음, 매퍼 인터페이스를 구현한 클래스의 메서드를 사용하게 된다면, 이는 곧, @Override한
                매퍼 인터페이스의 메서드를 쓰는것과 같으며, 그 안에는 sqlSession.~()메서드를 실행하는것과 같다.
                또한, 만약에 매퍼 인터페이스의 메서드(구현한 클래스의 메서드에도)에 파라미터가 있다면, 이도 똑같이,
                sqlSession.~()메서드에 그대로 그 파라미터 값이 전달된다.
                [참조링크 : https://bigfat.tistory.com/95]
            2.이제 넘어가는것이 xml 파일인데, 여기서는 나름의 순서대로 체크를 하고 코드를 쓰는것같다.
                xml방식으로 우선 해당 매퍼 인터페이스의 메서드에 해당하는 xml파일의 코드를 해석하고 그다음 <mapper>태그 안의 해당 메서드에 해당하는 
                코드들을 마이바티스 방식으로 분석한 후 최종 쿼리문을 데이터베이스로 보내는것같다. 아래에 더 자세히 보겠다. (분명 다른 부분도 있으나 우선 이렇게 생각하자.)
                    2-1.xml방식으로 해석
                        우선적으로 매퍼 인터페이스의 메서드에 해당하는 코드를 xml방식으로 해석한다. 즉, <mapper>내에 해당 메서드에 해당하는
                        코드들을 xml방식으로 해석하고 나서 이 코드들을 마이바티스식 분석으로 보내는 거다. 더 자세히 내용을 얘기해보겠다.
                            1.<insert id="~" parameterType="~" resultType="~"> ~ </insert>외에 insert부분말고 update, delete, select가
                                들어가더라도 이 부분은 그냥  매퍼 인터페이스의 실행된 메서드명과 이 태그의 속성 id부분만 같다면 아무 작용도 하지 않는다.
                                [직접해봄]   
                                +
                                추가로, 이 <insert> <update> <select> <delete>에 관련된 태그는 xml방식으로 해석한다기보다,
                                그저 마이바티스식 분석을 할때 다른 쿼리문과 구분해주는역활을 하는것으로 보면될것같다.   
                            2.<,>,& 같은 특수문자들을 태그나 기타 xml방식으로 인식해서 적용해 버릴 수 있다고 한다. 그래서 에러나
                                다른 기타 상황이 생길 수 있는데 이를 막고자 CDATA라는 코드를 사용한다. 아래에 추가사항에 설명하겠다.
                                [참조링크 : https://java119.tistory.com/70] / <mapper>내에 있는 <,>,&를 xml에선 태그나 기타 xml방식으로 이해
                                [참조링크 : https://writemylife.tistory.com/m/65]       
                            3.동적쿼리의 사용은 통상 xml에서 해석하여 반영하는것으로 알고있다. 왜냐하면, 모르고 <![CDATA[ ~ ]]>를
                                ~ 안에 동적쿼리 <if test~>를 넣었더니, 마이바티스 분석에서 데이터베이스에 이 그대로를 전달하는거였다. 그러니 xml파서에서 처리할때
                                적용하는것으로 보아도 될것 같다. 자세하게 더 알아야 할 사항이 있으면 다시보고 아래에 더 구체적으로 봐보겠다.
                                (여기서는 <if>동적쿼리에 대해서만 다룬다. 만약 다른 동적쿼리들도 이와같은지는 직접 해봐야 안다. 또한, 파라미터로 보내지는 형들이
                                DTO, String, int형만 고려하도록 하겠다. 나머지는 적용이 필요하게 되면 사용하도록 하자.)
                                [직접해봄]
                                    (1).그럼 <if test="~"> ~~ </if> 동적쿼리에 대해 알아보겠다.
                                        {1-1}.<if test="~">~~</if>동적쿼리는 test속성안에있는 ~ 부분이 true/false의 결과값으로 나오는 boolean타입의 조건식이
                                            들어가게 되는데, 만약에 해당 조건식이 true면 <if>태그 내의 ~~ 부분의 내용을 그대로 마이바티스로 보내고 만약 false의
                                            값이 나오게 되면, 해당 ~~ 부분을 아예 마이바티스분석을 못하도록 감춰버리는것같다. 아예 쿼리문이 안나타난다.
                                            또한, 값이 true일때 <if>문은 마이바티스식 분석을 할때 아예 포함을 안시키거나 나타나지 않는것으로 보인다.(이 <if>코드부분이
                                            마이바티스방식 해석할때까지 넘어가게 되면 그대로 데이터베이스로 보내기 때문에 내 생각에 쿼리코드만 남고 이 <if>코드는 사라지는것같다.)
                                            또한, test속성값이 false인 경우 쿼리코드뿐만 아니라 <if>태그도 함께 사라지게 되는것같다.
                                            [직접해봄]   
                                            [참조링크 : https://goodteacher.tistory.com/249]    
                                        {1-2}.위의 test속성의 ~에 조건식을 작성할 때 보통 파라미터의 값을 기준으로 하는경우가 많다고 한다. 이때 파라미터를 참조할때는
                                            해당 파라미터 명을 그대로 가져다 쓰는데, 아래에 parameterType에 대해서 보면, int형은 애초에 xml파일 올때 interger로 변해서
                                            오고(다를경우 그때가서 다시 보자) String형은 그대로, 그리고 dto형의 경우도 그대로 xml파일로 보내게 된다. 이 얘기를 하는 이유는
                                            xml 파서(xml방식 해석)를 할때는 #{},${}형태가 아닌 이 파라미터명을 그대로 써야하기 때문이다.
                                            [참조링크 : https://goodteacher.tistory.com/249]    
                                            [참조링크 : https://taesikman1.tistory.com/24]  
                                                1.int형의 파라미터를 받아오는경우 xml파일로 받아오기전에 integer형으로 보내져서(아래 설명참조) 참조하게 되는건데 이때도 그냥 int형일때의
                                                    파라미터명을 그대로 쓰면 된다고 한다. 아마 xml파일에서 알아서 자동적으로 값을 넣어주는것같다.
                                                    예시)
                                                        <if test="boardIdx!=0">
                                                            WHERE board_idx=${boardIdxa} AND deleted_yn='N' ORDER BY board_idx DESC
                                                        </if>
                                                    boardIdx라는 int형을 매퍼 인터페이스 파라미터로 부터 받은것이다.
                                                    [직접해봄] / boardIdx로 해봄
                                                    [참조링크 : https://taesikman1.tistory.com/24] / 여긴 parameterType이 String이지만 int(_int상관없다)도 이와 같다.   
                                                2.String형의 파라미터를 받아오는경우 xml파일에서는 그대로 와서 사용하는것 같다. 실제로 매퍼 인터페이스의 메서드의 파라미터로
                                                    xml파일이 넘어올때 String형의 경우 아무 변환도 일으키지 않고 그대로 쓰는것으로 알고있다.(아래 parameterType참고)
                                                    이 경우에도 매퍼 인터페이스의 파라미터타입에서 넘겨온 파라미터명을 그대로 쓴다.
                                                    예시)
                                                        <if test="boardIdx!=null">
                                                            WHERE board_idx=${boardIdxa} AND deleted_yn='N' ORDER BY board_idx DESC
                                                        </if>
                                                    boardIdx를 받아오는것을 <a href=>로 쿼리스트링을 받아오던, form태그의 GET이나 POST방식으로 받아오던
                                                    어차피 String형태로 받아오는것이기에 이걸 컨트롤러의 @RequestParam으로 String형으로 받아온것을 쓴것이다. 
                                                    [직접해봄] / boardIdx를 컨트롤러에서 String형으로 받아서 해봄
                                                    [참조링크 : https://taesikman1.tistory.com/24]
                                                3.DTO형의 파라미터를 받아오는경우 xml파일에서 그대로 와서 사용하게 되는데, 위의 String형과 같게, 매퍼 인터페이스의 메서드의 파라미터로
                                                    xml파일로 넘어올때 아무 변환도 일으키지 않고 그대로 사용하게 된다. 그러나 xml 동적쿼리(if문의 test속성)에서는 위의 파라미터명과는
                                                    조금 다르게 쓰이는데, 여기서는 필드명으로만 적어주어서 사용하게 된다. 아마도 알아서 get메서드라든지 방법을 써서 dto형의 값을 갖고와서
                                                    test속성에 쓰게되는것같다.
                                                    예시)
                                                        <if test="title!=null">
                                                            ~
                                                        </if>
                                                    boardDto의 파라미터타입으로 위의 title은 이 dto의 필드명중 하나이다.
                                                    [직접해봄] / 위의 예시문
                                                    [참조링크 : https://velog.io/@ednadev/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%A7%88%EC%9D%B4%EB%B0%94%ED%8B%B0%EC%8A%A4-MyBatis] / 여기에 parameterType이 user일때 예시문있다.    
                                    (2).위와같은 동적쿼리의 내용특성상 CDATA내에 동적쿼리(<if>)를 쓰게되면 그대로 문자열로 마이바티스식 분석으로 넘어가
                                        버리기 때문에 동적쿼리를 사용할 수 없게 된다. 따라서 동적쿼리를 사용하고 싶다면, <,>를 사용하는 부분에만 CDATA를
                                        적용하여 사용하면 된다.
                                        [참조링크 : https://sdevstudy.tistory.com/6]   
                                        [참조링크 : https://writemylife.tistory.com/m/65]   
                            [추가사항]
                                1.CDATA의 개념과 사용에 대해 알아보자.
                                    (1).<![CDATA[ ~ ]]>와 같이 사용하며, 해당 기능은 xml파서일때 즉, xml방식으로 해석할때
                                        이 코드 부분이 감싼 ~는 그냥 문자열로 취급한다는것이다. 그렇게 한 후에 마이바티스식 분석으로
                                        넘어가서 쓰이게 되는거다. 그래서 <,>,&등을 xml파서부분에서 오류없이 넘어가서 마이바티스에서
                                        등호나 기타 등의 기능으로 쓸 수 있는것이다. 또한 마이바티스식 분석에서는 이 코드 부분을 아예 없는취급하는것 같다.
                                        아래 더 살펴보겠다.
                                        [참조링크 : https://java119.tistory.com/70]       
                                    (2).사용코드는 <![CDATA[ ~ ]]>로 사용하게 된다. 이 코드는 <select> <insert>등의 태그 내의
                                        쿼리코드를 전체를 감싸서 사용할 수도 있고, WHERE 쿼리코드만 감싼다던지, 아니면 글자 하나 > 부등호
                                        표시만 감싼다던지 자유롭게 사용이 가능하다.
                                        [참조링크 : https://sdevstudy.tistory.com/6] / < 글자 하나만 감쌈
                                        [참조링크 : https://epthffh.tistory.com/entry/Mybatis-%EC%97%90%EC%84%9C-CDATA-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0] / 쿼리문 전체 감싸기  
                                    (3).xml파서에서 특수문자(<,>,& 등등) 부분을 해석하여 에러가 날 수 있으므로,
                                        그런이유에서 <![CDATA[ ~ ]]> 를 특수문자가 없는 경우에도 하나의 규칙같이 전부
                                        CDATA를 쓰는곳이 많아졌다.
                                        [참조문헌 : 스프링부트 시작하기 초록책 69~88pg]   
                                        [참조링크 : https://epthffh.tistory.com/entry/Mybatis-%EC%97%90%EC%84%9C-CDATA-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0]
                                2.위에서 보는 xml방식으로 해석한다는것을 xml파싱(parsing)라고 한다.
                                    xml방식과같이 분석하여 적용하는것을 파싱이라고도 하고 아예 컴파일과 파싱을 같은의미로 부르는 경우가 있는것같다.
                                    또한 세번째 참조링크를 보면, 파싱은 컴파일을 하기위해 컴파일전 의미있는 단위로
                                    잘라서, 해석한다음 컴파일이 가능하게되어 컴파일 후에 실행가능한 상태가되는 의미로도
                                    이해해도 될 것 같다. 또 다른 참조링크들을 보면 파싱과 컴파일을 같은 의미로 쓰기도 한다.
                                    아래의 내용을 예로들면, 쿼리문을 DBMS에 보내고나서 DBMS에서는 이 쿼리문을 컴파일 한 후에 실행하게 되는데,
                                    이때 compile이 아닌 파싱이라고도 한다. 
                                    [참조링크 : https://java119.tistory.com/70]   
                                    [참조링크 : https://sdevstudy.tistory.com/6]  
                                    [참조링크 : https://m.blog.naver.com/PostView.nhn?blogId=truelite&logNo=20159615998&proxyReferer=https:%2F%2Fwww.google.com%2F]   
                                    [참조링크 : https://java119.tistory.com/39] / DBMS에서 쿼리문을 컴파일할때 파싱이라고도 한다고 나와있다.
                                    [참조링크 : https://madplay.github.io/post/difference-between-dollar-sign-and-sharp-sign-in-mybatis] / DBMS에서 쿼리문을 컴파일할때 파싱이라고도 한다고 나와있다.
                                3.xml파일의 동적쿼리에서 <,>등을 쓰고싶을때나, 쿼리문에서 CDATA없이 <등을 쓰고 싶을때
                                    (1).xml의 동적쿼리에서 <,>를 쓰고싶은 경우에, 즉 <if test="value<0">와 같이 동적쿼리문에서(xml 파서방식이니) 부등호를 사용하고
                                        싶은경우에는, <는 lt >는 gt <= or =<는 lte >= or =>는 gte로 대신해서 쓰면 알아서 해당하는 부호로 해석하게 된다.
                                        xml파서 방식일때 이 test속성안의 <,> 도 태그로 해석하기 때문에 사용하지 못한다. test속성말고 다른 동적쿼리 사용시는 그때가서 알아보기
                                        또한, 여기 test속성값에서 &lt, &gt, &lt;, &gt;같이 적어주니 오류났었다.
                                        [직접해봄]   
                                        [참조링크 : https://kimtaekju-study.tistory.com/168]    
                                        [참조링크 : https://m.blog.naver.com/PostView.nhn?blogId=admass&logNo=220548334257&proxyReferer=https:%2F%2Fwww.google.com%2F]
                                    (2).동적쿼리의 test의 속성값에서 쓰는게 아닌, 쿼리문에서 <,>부등호를 쓰고 싶은경우에는 추가로 &와 ;를 붙여야 제대로
                                        작동한다. 즉, 위의 <는 &lt;, >는 &gt;, =<는 &lt;= 그리고 =>는 &gt;=로 써야지 마이바티스식 분석에서 부호로 여기고 해석한다.
                                        보니까, test속성값으로 lt나 gt는 xml파서에서 해석하지만 그 외의 쿼리문에서의 gt나 lt는 문자열로 그냥 보는것같다.
                                        또한, 어디서는 &lt, &gt만 적어도 된다고 써있으나 실제로 해보니 ;까지 붙여줘야 제대로 작동한다.
                                        [직접해봄]   
                                        [참조링크 : https://reference-m1.tistory.com/308]
                                    (3).추가적으로 > 부호에 대해서는 xml파서에서 태그로 인식하지 않아서 해석하지 않고 그대로 마이바티스식 분석으로 넘겨 버린다.
                                        그렇기에 마이바티스식 분석에서는 이를 부등호로 해석하여 사용한다. >의 경우는 이럴수도 있나보다.
                                        [직접해봄]
                                    (4).<if test="~">
                                            ~~
                                        </if>
                                        여기서 ~~에 <,>를 써도 xml방식에서 태그로 인식하고 오류를 발생시키는데, 그 이유가 위의 test의 속성 ~이
                                        boolean값이 참이면 해당 <if> 태그들만 사라지고 마이바티스방식으로 분석할때 ~~분석코드를 보내고 또는 ~의
                                        boolean값이 false이면 <if>태그들을 포함한 ~~에 대한 내용도 모두 사라져서 마이바티스 방식으로 분석할때 해당 내용들이 안보이나
                                        이는 마이바티스 분석방식으로 보내기전에 처리하는것으로 이 여부에 상관없이 ~~에 <,>와 같은 xml파서가 태그등으로
                                        해석할만한게 있으면 그대로 xml파서방식으로 해석하는것같다. 이 부분 다를수도 있으나 이렇게 이해하면 될것같다.
                                        [직접해봄] / 직접 ~~에 <,>쓰니 xml방식에서 태그시작으로 인식함
                                        +
                                        물론, gt lt같은것은 xml파서일때 동적쿼리 test속성값에서 부등호의 기능을 갖는 의미가 있는것이고 마이바티스방식의 분석에서는 이는 그냥
                                        문자열에 불과하기 때문에, 마이바티스방식의 분석에서 부등호와 같은 특수문자를 쓰려면 꼭 CDATA를 사용해주거나 위의 &lt;, &gt;와 같이 써주어야 한다.
                                        [참조링크 : https://kimtaekju-study.tistory.com/168]    
                                        [참조링크 : https://m.blog.naver.com/PostView.nhn?blogId=admass&logNo=220548334257&proxyReferer=https:%2F%2Fwww.google.com%2F] 
                                4.매퍼 인터페이스의 메서드의 파라미터 타입에 기본타입이 들어가게 되면, 알아서 xml으로 넘길때 auto-boxing으로
                                    래퍼파일에 값을 넣어서 전달하게 된다고 한다. 또한, 이 래퍼파일들은 기본적으로 get메서드가 없다고 한다.
                                    [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95] / 매퍼 인터페이스의 메서드의 파라미터 타입이 기본타입인경우 auto-boxing으로 래퍼객체로 만들어서 xml에 전달한다. 또한 래퍼파일들은 get메서드가 없다고 한다.                                                 
                    2-2.마이바티스 방식으로 해석
                        xml파서로서 해석한 후에 <mapper>내의 매퍼 인터페이스의 메서드명과 <>태그의 id에 해당하는 내의 쿼리문에 대해 마이바티스
                        식 분석으로 해석하게 되는것 같다. 위의 xml방식에서 넘어오는것에 대해 한번더 정리하자면, CDATA에 관련된 문구는 마이바티스식 분석에서는
                        나타나지 않고, <if>문도 나타나지 않는 것으로 알고 있다. 또한, 마이바티스식 분석에서는 또 나름의 분석과정이 있는데 이 과정을 보겠다.
                            (1).우선적으로, parameterType(<select>,<insert>,<update>,<delete>에 모두 있는 속성)과 resultType(<select>에만 있는 속성)의
                                 기능인 parameterType은 매퍼 인터페이스의 파라미터의 형과 같은지 그리고 resultType은 매퍼 인터페이스의 반환형과 같은지를
                                 (자세한건 아래에 parameterType과 resultType참고) 비교하는 작업을 이곳에서 하는것 같다.
                                 [직접해봄] / 형이 다를 경우 에러가 발생했었다.'
                            (2).${}나 #{}가 쿼리문에 있을때 그리고 #{}와 ${}가 동시에 쿼리문에 있을때를 상황으로 마이바티스방식의 처리 방식을 살펴보겠다.
                                물론, 이를 이렇게 될거다 라는 사실에 근거한 재해석이기 때문에 나중에 문제가 되거나 다를시에 다시 보도록 하자.
                                1.쿼리문에 ${}만 있는 경우(Statement객체 생성)
                                    (1-1).이 경우에는, statement객체만 생성시키는것 같다. 그런 다음, 이 statement객체에 해당 xml파일의 쿼리문만을 담고,
                                        ${} 부분에 대해서는 값을 넣어준다음에 RDBMS로 값이 넣어진 쿼리문을 그대로 RDBMS에 보내게 되는거다.
                                        [참조링크 : https://mine-it-record.tistory.com/300] / RDBMS로 쿼리문 전달 , 실제 수행 쿼리문
                                        [참조링크 : https://www.podo-dev.com/blogs/107] / RDBMS로 전송된 쿼리문에는 ${}에 값이 들어가진채로 전송되는거다.  
                                        [참조링크 : https://devbox.tistory.com/entry/Comporison] / RDBMS로 전송된 쿼리문에는 ${}에 값이 들어가진채로 전송되는거다.     
                                    (1-2).
                                        ㅁ
                                        [참조링크 : ]   
                                    (1-3).
                                2.쿼리문에 #{}만 있는 경우(preparedStatement객체 생성)
                                    (2-1).이 경우에는, preparedStatement객체를 생성시키는데, 이 preparedStatement객체에 해당 xml파일의 쿼리문을 담는데,
                                        #{} 부분에 대해서는 ? 로만 넣어주고 preparedStatement객체에서 그대로 RDBMS에 쿼리를 보내준다. 또한, preparedStatement객체는
                                        set메서드로(preparedStatement 객체의 메서드임), 쿼리문의 해당 #{}의 순서와 갯수에 맞게 preparedStatement객체 자신에 값을 저장한다.
                                        그런다음에, 쿼리문(#{}가 ?로 표현된)을 DBMS로 보낼때, 이 저장한 값들도 함께 보내게 된다고 한다. 또한, preparedStatement의 set메서드를
                                        사용하는 코드에서 파라미터에 1,2, 이렇게 숫자가 있는데 이는 #{}가 쓰여진 순서대로 번호가 메겨진것이다.
                                        [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95] / preparedStatement객체의 set메서드를 통해 #{}에 해당하는 값들을 preparedStatement객체에 저장한다
                                        [참조링크 : https://cocodo.tistory.com/11] / preparedStatement의 set메서드의 숫자는 #{}순서대로 번호가 메겨진거다.
                                        [참조링크 : https://www.podo-dev.com/blogs/107] / #{}에 해당하는 실제값이 DBMS로 쿼리문 처럼 전송된다.
                                        [참조링크 : https://madplay.github.io/post/difference-between-dollar-sign-and-sharp-sign-in-mybatis] / #{}가 쿼리문에 있을경우 preparedStatement객체 생성
                                    (2-2).DBMS에 쿼리문과 #{}에 해당하는 값들이 보내지고 나서의 과정
                                        #{}가 포함된 쿼리문이 DBMS로 보내지면 이에 대한 값도 DBMS로 보내지게 된다. 그러면, 아래 두번째 참조링크를 보면 우선적으로 컴파일을 하고
                                        그 다음에, ?에 해당하는 값을 바인딩한다음에 그러고 나서 해당 쿼리문을 실행하게 된다. @@@@@@@@@@@
                                        1.#{}는 쿼리문의 #{}값이 달라도 컴파일을 한번만 진행한다. 이를 여기선 캐싱이라고 하는것같다. 당연히
                                            #{}외의 다른 쿼리문이 달라지면, 다른 쿼리문으로 인식하기에 컴파일을 진행할거다.
                                        2.${}는 쿼리문에서 ${}값이 달라지면, 다른 쿼리문으로 보고 이를 매번 컴파일 하는것으로 알고 있다. 하지만,
                                            만약 ${}값이 변하지 않는다면, 여기도 컴파일을 매번 진행하지 않고 실행하는것으로 알고있다.
                                        3.그럼 당연히 ${}보다 #{} 성능이 좋아보이겠지만, DBMS마다 이 또한 다르다고 한다. Mysql같은 경우는 실제로
                                            이 둘의 차이가 없다고 글에 나와있다.
                                        4.즉, 어느정도 ${}는 잘 변하지 않거나 입력받은 값이 아닌걸로 사용하며, #{}는 값이 변하거나 입력받은값(sql 주입예빵되니)으로
                                            사용된다고 하니 이러한 기능에 초점을 맞춰서 작성해 주는게 좋을 것 같다. 속도나 성능에는 연연할 필요가없다는 말이다. 혹시모르니 체크정도
                                        [참조링크 : https://devbox.tistory.com/entry/Comporison] / DBMS에서는 1)쿼리 문장 분석, 2)컴파일, 3)실행 의 과정을 거쳐 쿼리문을 사용한다.(Statement, PreparedStatement객체 둘다 이와 같다.)
                                        [참조링크 : https://www.podo-dev.com/blogs/107] / SQL문을 먼저 컴파일 후에, ?에 해당하는 값을 바인딩하고 그리고 실행한다.
                                        [참조링크 : https://rh-cp.tistory.com/71] / 여기에 이미 #에서는 컴파일하고 값 바인딩하기에 값이 달라져도 같은 쿼리로 여기며, $는 값이 달라지면 다른 쿼리로 여겨져서 그렇다고 한다 이거 다시 정리 @@@@@@@@@@
                                    (2-3).위의 (2-1).에서 preparedStatement객체에 관한 설명을 할때, int나 String형은 #{}사용시에, 그대로 값을 1:1 매칭시켜주어서
                                        get메서드가 사용되지 않는것으로 보고있다. 아래 참조링크만 봐도, get메서드대신 그냥 그 변수 그 자체가 쓰이는것으로 보고 있다.
                                        또한, 아래의 참조링크를 보면, DTO의 경우는 반드시 DTO의 get메서드를 사용하여 값을 받아오는것으로
                                        보고 있다. 당연히 integer형의 경우도 알아서 값을 내와서 DTO의 get메서드자리나 String의 변수자리에 놓이는것 같다.
                                        [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95] / 보면, 파라미터타입이 int,String은 나와있지 않지만, DTO의 경우 DTO의 get메서드를 통해 값을 가져온다고 나와있다.
                                        [참조링크 : https://cocodo.tistory.com/11] / 여기를 보니 int나 String은  DTO의 get메서드가 쓰이는자리에 그대로 변수(int나 String의)가 쓰이는것 같다.
                                3.쿼리문에 #{}와 ${}가 있는 경우
                                    ㅁ
                                    [참조링크 : ]   
                                [추가사항]
                                    (1).아래 참조링크에도 마이바티스에서, ${}는 Statement객체이고 #{}는 PreparedStatement객체라고 설명되어있다.
                                        [참조링크 : https://www.podo-dev.com/blogs/107]   
                                    (2).ㅁ@@@@@@@@
                                        [참조링크 : ]    
                                    DATE_FORMAT()함수는 Mysql의 함수다. 즉, 이거는 그냥 데이터베이스에 그대로 보내는거다. 즉,
                                    xml은 <,>,&와 같은 특수문자와 <if>말고는 다른거 추가적으로 xml으로 인식하는거와 추가로 생기면 또 정리하자라고 적고
                                    마이바티스방식의 해석은 #{}와 ${}밖에는 없는것같다. 이것도 나중에 추가로 생기면 다시정리
                                    +
                                    여기서,그 머냐, statement는 매번 컴파일 해줘야하며, preparedstament는 그렇지 않으니 성능상 이점이 preparedstatement
                                    가 더 있다고 하는데, 지금은 버전(무선버전이지) 가 올라가면서 mysql에서는 이 부분이 크게 차이가 안난다고 한다. 이거는 그
                                    ? 부분과 num 부분이 데이터베이스에서 컴파일 하는거와 다른건가 아닌 같은건가 모르겠네
    (3).마이바티스의 <mapper>내의 쿼리문에서 #{~},${~}의 작동원리와 개념설명
        1.#{~}의 작동원리와 개념설명
            {1}.동적쿼리(위의 if문의 경우, 다른 동적쿼리는 안해봤으나 필요할 경우 그때가서 다시 봐보자)의 안에서 쓰이는 경우
                1-1.파라미터 타입이 String형 인 경우
                    아래의 참조링크를 보면, 파라미터타입이 String형이면서 <if>문 안에 쓰이는 경우 get메서드를 이용해서 값을 받아오기에
                    String형은 get메서드가 없어서 에러가 발생한다고 나와있다. 또한, 다른 참조링크들을 봐도 전부 그렇게 나와있다. 그러나 내
                    마이바티스가 최신이여서 그런지(xml방식에서 마이바티스방식으로 넘어왔을때 마이바티스방식에서 해석방식이 최신버전이여서 좀 다를수도),
                     <if>문 안에 #{변수명}, #{다른 어떠한 명}, #{value}을 넣어도 모두 정상적으로 작동하였다. 또한, 본래 참조링크들을 보면, #{변수명}은
                    get방식으로 값을 받아오기때문에 #{value}로 하면 알아서 값이 매칭된다고 나와있다. 그러나 마이바티스가 최신이여서 그런지 #{변수명}, #{value},
                    #{다른 어떠한 명}도 모두 get방식이 아닌 그대로 값을 매칭시켜주는것같다.
                    [직접해봄] / <if>문 안에서 #{변수명}, #{다른 어떠한 명}, #{value}모두 정상 작동했다.
                    [참조링크 : http://blog.naver.com/PostView.nhn?blogId=roropoly1&logNo=221184569655&parentCategoryNo=&categoryNo=9&viewDate=&isShowPopularPosts=true&from=search] / 여기서는 동적쿼리 <if>안에서는 #{변수명}일시 get방식으로 값을 얻어오기 때문에, #{value}해야 값이 get방식을 안쓰고 매칭된다고 나와있다
                1-2.파라미터 타입이 int,_int형(기본 타입) 인 경우
                    아래 참조링크를 보면, long이나 int형(기본형은 다 해당되는듯 하다.) 기본타입들은 <if> 동적쿼리 안에
                    #{변수명}을 적을시 getter 방식으로 값을 갖고온다고 한다. 그렇기에, 에러가 안나려면 #{value}로 해주어야 값을
                    그대로 매칭해준다고 한다. 즉, getter를 쓰는게 아니라 그냥 값을 매칭시켜주는방식인거다. 그러나, 실제로
                    내가 직접해보니 마이바티스가 최신이여서인지는 모르겠으나, #{변수명}, #{value}, #{다른 어떠한 명} 모두 값이
                    잘 매칭되어서 실행이 됬었다. 마이바티스가 최신버전이라 그런걸수도 있고 만약에 이 부분이 나중에 다시 문제가
                    된다면 다시 봐보도록 하자.
                    [직접해봄] / <if>쿼리문 내에서 #{변수명}, #{value}, #{다른 어떠한 명}이든 모두 정상 작동했다.
                    [참조링크 : https://gdtbgl93.tistory.com/95] / 기본자료형(long 등등)도 <if>쿼리문 내에서의 #{변수명}은 get메서드를 이용해서 받아온다.
                    [참조링크 : https://everydaycoding.tistory.com/category/Springframework] / 원시타입, 즉, int나 long타입같은거도 <if>쿼리문 내에서 #{value}쓰면 알아서 값이 잘 매칭이된다는말
                    +
                    위에서 xml방식에서 보듯이, 여기는 int타입의 매퍼 인터페이스의 파라미터타입을 받으면, 자동으로 xml방식해석전에
                    integer객체에 담아서 변형시켜서 받기에, 여기서도 마이바티스방식에서 값을 매칭시킬때, 자동으로 integer객체에서
                    값을 갖고와서 매칭시켜주는것으로 생각하면 될것 같다.
                1-3.파라미터 타입이 DTO형 인 경우
                    이 경우에는, 아래에 보듯이, <if>문 안이 아니더라도 DTO를 사용하는 경우에는 #{변수명}과 같이 쓰며
                    이를 사용할때, DTO의 get메서드를 가져다가 값을 대입하는거로 나와있다.(위의 preparedStatement보면 이해 더욱 잘됨)
                    그러니, <if>문 안이더라도 #{변수명}처럼 변수명을 써야하는것은 똑같으며, 값을 연결시켜줄때도 DTO의 get메서드를 사용하여
                    연결시켜줄것으로 보고 있다. 즉, <if>문에 상관없이 사용법이나 적용되는 방법이 같은것으로 보고있다. 만약에 조금
                    다른 부분이 있거나 틀린 부분이 있으면 나중에 필요시 다시 보도록 하자.
                    [직접해봄] / <if>문 안에 파라미터 타입이 DTO인 경우 사용해봄
                    [참조링크 : https://velog.io/@ednadev/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%A7%88%EC%9D%B4%EB%B0%94%ED%8B%B0%EC%8A%A4-MyBatis] / <if>문안에 파라미터타입이 DTO인 경우   
            (2).동적쿼리 내가 아닌 일상 쿼리문에서 쓰이는 경우
                2-1.파라미터 타입이 String형 인 경우
                    아래의 참조링크에서도 보듯이, <if>의 동적쿼리문안이 아니면 get메서드를 사용하지 않는것 같다. 그러하기에,
                    아래의 참조링크는 #{변수명}이 된다고 적어놨지만, 직접해보니 #{변수명}, #{다른 어떠한 명}이 3가지 모두 정상작동하였다.
                    즉, 어차피 매칭되는값은 하나이기에, 무엇을 적든 get메서드를 사용하지않고 바로 값을 넣어주는것같다.
                    [직접해봄] / #{변수명}, #{value}, #{다른 어떠한 명} 모두 해봤더니 잘 되었다.
                    [참조링크 : http://blog.naver.com/PostView.nhn?blogId=roropoly1&logNo=221184569655&parentCategoryNo=&categoryNo=9&viewDate=&isShowPopularPosts=true&from=search] / if문의 동적쿼리내에서 #{변수명}을 사용시에는 get메서드를 쓰지않는다.     
                2-2.파라미터 타입이 int,_int형(기본 타입) 인 경우
                    위에도 적어놨듯이, 매퍼 인터페이스의 메서드의 파라미터가 int형이면 xml로 넘겨줄때 즉, xml방식을 적용하기 이전에
                    이미 integer객체로 변환이 되어서 적용이 된다. 이 경우에는 따로 찾아본 내용은 없지만, 위의 <if>문 안에서의 int,long에 대한
                    내용을 보면, <if>문이 아닐때는 일반적으로 #{변수명}, #{다른 어떠한 명}, #{value}모두 값을 1:1 매칭해주는것 같다. 만약
                    다르거나 다시 봐야할 부분이 있다면 그때가서 고려하도록 하자.
                    [직접해봄] / #{변수명}, #{다른 어떠한 명} 모두 해봤더니 잘 되었다.
                    [참조문헌 : 스프링부트 시작하기 초록책 81pg] / <if>문이 아닌데서 #{변수명}으로 쓰이는모습
                2-3.파라미터 타입이 DTO형 인 경우
                    파라미터 타입이 DTO인 경우, 해당 필드값을을 쓸때 #{필드명}으로 가져다 쓰는것 같다. 이 필드명은 반드시
                    맞춰주어야 매칭이 되는것 같다. 위의 마이바티스 방식 preparedStatement에 관한글을 보면 더 쉽게 이해가 될것이다.
                    만약 다른 내용이 있다면 그때가서 다시 정리하며, 또한 이 <if>동적쿼리문 안이 아니더라도, 이 #{변수명} 값들을
                    연결시켜줄때 기존 DTO의 get메서드를 이용하여 값을 연결시켜준다. 이 부분도 위의 preparedStatement를 보면 더욱
                    잘 이해가 될것이다.
                    [직접해봄] / <if>문이 아닌곳에서 DTO를 사용해봄  
                    [참조문헌 : 스프링부트 시작하기 초록책 88pg, 76~77pg] / <if>가 아닌데서 DTO가 쓰인경우 
                    [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95] / 여기에 봐도 DTO의 get메서드를 사용 
            (3).#{}에 대한 추가내용들
                3-1.아래 참조링크를 보면, 쿼리문에 #{}가 있는 경우 컴파일 - 바인딩 - 쿼리문실행의 3단계를 거치는데(자세한건 위의 글 참고) 이 컴파일 과정에서
                    아예 해당 쿼리문의 원본의 기능이 고정이 되어서, 값이 바인딩되어 들어올때 hi, 'title'와 같은 문자열을 넣어도 SQL 주입이 예방되는거다.
                    @@@@@@@
                    [참조링크 : https://www.podo-dev.com/blogs/107]
                3-2.#{}를 사용하는 경우에, 해당하는 값은 파라미터타입이 DTO형의 int나 String필드를 사용하건, 파라미터타입이 int형 or _int형이여서 integer로 된것의 값을,
                    사용하건, 파라미터타입이 String형인것의 값을 사용하든지간에, 무조건 값에 작은따옴표를 붙여서 바인딩이 되고나서 쿼리문에 실행이 되게 된다.
                    즉, 기존에 문자열 타입뿐만이 아니라, 메서드 인터페이스의 파라미터타입이 int형이건, DTO형의 필드타입이 int형이건, 무조건 #{}를 쓰면 '값' 처럼
                    ''작은따옴표가 붙는다는거다. @@@@@@@@@@@@@@@
                    [직접해봄] / 실제로, INSERT문제 값을 넣는 부분말고 컬럼명에 #{}를 쓰니 에러 발생했었다.   
                    [참조링크 : https://logical-code.tistory.com/25] / #{}는 값에 ''를 감싸서 나온다.
                    [참조링크 : ] /   @@@@@@@@@@@@@@
                ㅁㅁㅁㅁㅁㅁㅁ여기서부턴, 이제 보안이라든가 "가 붙는다든가 등등 설명"
                ㅁ
                [참조링크 : ]    그 ${}는 진짜 어떤값이든 그 값만 나오고 #{}는 무조건 따옴표 붙여서 나온다. + 애초에 ${}는 따옴표를 안붙이는거같긴해 + ${}는 get,set을 안쓰는건가.
        2.${~}의 작동원리와 개념설명
            {1}.동적쿼리(위의 if문의 경우, 다른 동적쿼리는 안해봤으나 필요할 경우 그때가서 다시 봐보자)의 안에서 쓰이는 경우
                1-1.파라미터 타입이 String형 인 경우
                    아래의 참조 글을 보면, <if>문내에서의 ${변수명}도 get메서드를 이용하여, String은 get메서드가 애초에 없기에 에러가 난다고 한다.
                    그러기에, #{value}를 적어주어야 매칭이 된다고 하는데, 여기서도 ${value}에 대한 내용은 없다. 그러나 직접해본결과, ${변수명}, ${다른 어떠한 명}, ${value}
                    이 3가지 경우 어떤것이든, 값이 매칭되었었다. 즉, 마이바티스가 최신버전이여서 그런지 모르겠으나, get메서드를 사용하지 않고 바로 매칭시켜주는것같다. 여기서도 보듯이
                    참조 글의 상황에 경우는 ${value}가 되는지 안되는지는 알아볼 수가 없다.
                    [직접해봄] / ${변수명}, ${다른 어떠한 명}, ${value} 이 모든것에 대해서 값이 제대로 작동하였다.
                    [참조링크 : https://aljjabaegi.tistory.com/457] / 파라미터타입이 String형인경우, <if>내에서 ${변수명}도 get 메서드를 사용하기에 에러가 난다고 나와있다.
                1-2.파라미터 타입이 int,_int형(기본 타입) 인 경우
                    위의 ${}가 파라미터타입이 String형인 경우에도, <if>동적쿼리문 안에 쓰면 get메서드 방식을 사용하기에 오류가 난다고
                    나와있다. 짐작에, int형 타입도 아무리 xml에 넘어올때 integer로 넘어온다고 하여도 integer는 get메서드가 없기에 오류가
                    날꺼라고 가정을 하겠다. 그러나 직접 해보니, 마이바티스가 최신버전이여서 그런지, <if>동적 쿼리문 안에 ${}가 있어도 정상적으로
                    작동하였다. ${변수명}, ${다른 어떠한 명}, ${value} 이 모든게 정상작동한것으로 보아, 값은 get방식이 아닌 그대로 1:1매칭 시켜준
                    것으로 보아도 될것같다. 나중에 다시 볼 필요가 있을시에 다시 보도록 하자.
                    [직접해봄] / ${변수명}, ${다른 어떠한 명}, ${value} 이 모든것에 대해서 값이 제대로 작동하였다. 
                    [참조링크 : https://aljjabaegi.tistory.com/457] / 파라미터타입이 String형인경우 ${}의 경우 get메서드를 요구하기에 에러가 난다고 한다.
                    +
                    여기서는 애초에 ${변수명}은 안되니 ${value}가 했더니 되었다 라는것을 쓸 수가 없다. 이러한 글이 없고,
                    지금은 ${}안에 어떠한 명을 써도 되기 때문이다.
                1-3.파라미터 타입이 DTO형 인 경우
                    이 부분도 아래의 <if>문이 아닐때와도 크게 차이가 없는것 같았다. 실제로 DTO형을 파라미터 타입으로 받아
                    왔을때, 이를 DTO의 각 필드를 사용하려면, ${필드명}을 써서 사용이 가능했고, DTO에서 값을 가져오려면 get메서드 방식
                    밖에 없으니, get메서드 방식으로 보아도되며, 아래의 <if>문 내가 아닌경우가 비교했을때, 차이점이 없어보였다.
                    만약, 나중에 필요사항이 있다면 다시 봐보도록 하자.
                    [직접해봄] / DTO형으로 해당 필드명들과 같은명으로 ${명}을 써서 사용해보았다.  
            (2).동적쿼리 내가 아닌 일상 쿼리문에서 쓰이는 경우
                2-1.파라미터 타입이 String형 인 경우
                    이 경우에는, ${변수명}, ${다른 어떠한 명이든}, ${value} 이 모든것에 대해서 그냥 1:1 대입하는 방식으로
                    값이 들어가는것 같았다.(이게 get 메서드로 받아오는지 바로 대입이 되는지는 나와있지않으나, String형은 get메서드가 없다.) 위의
                    <if>문 안에서의 ${}의 받아오는 방식도 바로 값을 매칭시키는 방식같다.
                    [직접해봄] / ${변수명}, ${다른 어떠한 명이든}, ${value} 이 3개 모두 정상적으로 값이 넣어지고 작동되었었다.
                2-2.파라미터 타입이 int,_int형(기본 타입) 인 경우
                    우선적으로 일반적으로 다른 참조링크보면 다 잘 쓰이고 있으며, 그 외에도  ${변수명}, ${다른 어떠한 명}, ${value}
                    와 같은 방식으로 직접 해보았는데도 정상적으로 잘 작동하였다. ${}가 int타입에 대해서는 어떻게 값이 매칭된다고 나와있지는 
                    않으나, get메서드 방식은 아니며 일방적으로 1:1 매칭되는 방식인것 같다. 만약 나중에 다른 부분이 있거나 수정할 부분이
                    있으면 그때 다시 보도록 하자. 또한 값 매칭시킬때 integer에서 값을 갖고와서 매칭시키는거다.
                    [직접해봄] / ${변수명}, ${다른 어떠한 명}, ${value} 이 모든것에 대해서 값이 제대로 작동하였다.   
                2-3.파라미터 타입이 DTO형 인 경우
                    직접 DTO들의 필드명을 각각 사용할때 ${필드명}에 따라 사용하였고, 모두 정상작동하였다. 또한, ${}안에
                    사용하려는 필드명을 넣어야 하는것 같으며, 다른 참조링크들을 찾아보아도 이것이 get방식으로 받아오는건지는
                    나오지 않았었다. 하지만, 애초에 DTO에서 값을 받아오려면 get메서드 방식밖에 없으니 get메서드를 사용해서 받아왔다고
                     생각해도 무방할것 같다. 이 부분 나중에 필요할시에 다시 보도록 하자. 
                    [직접해봄] / DTO형으로 해당 필드명들과 같은명으로 ${명}을 써서 사용해보았다.
                    [참조링크 : https://sinna94.tistory.com/entry/MyBatis-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%82%BD%EC%9E%85%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EB%93%A4?category=696828] / ${}에 DTO의 필드사용시 ${변수명}으로 적는 내용   
            (3).ㅁ
                ㅁ
                [참조링크 : ]  
        [추가사항]
            {1}.ㅁ
                ㅁ
                [참조링크 : ]    
            {2}.ㅁ
                ㅁ
                [참조링크 : ]      
            {3}.ㅁ
                ㅁ
                [참조링크 : ] 
    (4).parameterType에 관해서 정리해 보도록 하겠다.(혹시 모르니 ,select,insert,delete,update에 관한 거 따로써넣기 그리고 위치바뀐것도 다시 적용)
        (3-1).string,int, dto의 대해서만 정리하고, 나머지 string,int의 배열이나 dto배열
            혹은 map이나 그 외의 타입들에 대해서는 필요한 경우 다시 정리하도록 하겠다.
            [직접해봄]
        (3-2).parameterType별로 정리내용
            기본적으로 xml파일의 이 parameterType과 매퍼 인터페이스를 구현한 클래스의
            메서드의 파라미터의 타입과 같은것으로 적는다는 가정으로 진행한다. 그리고 그렇게 해야한다.
            왜냐하면, 이 parameterType의 기능이 매퍼 인터페이스의 메서드의 파라미터의 자료형과 맞지
            않으면 오류를 낸다. 근데 resultType처럼 그 외의 기능은 없는것같다. 자세한것을 아래 설명하겠다.
            [직접해봄] / 매퍼 인터페이스의 파라미터 자료형이 int형이고 parameterType은 int로 하니 에러남
            1-1.타입이 int형인경우(+기본형 타입)
                1.이 경우 매퍼 인터페이스의 메서드의 파라미터의 타입이 int형인 경우로 한정하자.(Integer타입말고)
                    [직접해봄]
                2.매퍼 인터페이스의 메서드의 파라미터 자료형이 int일때, xml파일의 parameterType이 int(별칭이 int이고 자료형은 Integer)이거나
                    아니면 _int(별칭이 _int이고 실 자료형은 int)여도 오류 안나고 잘 작동한다.
                    [직접해봄]
                3.매퍼 인터페이스의 메서드의 파라미터 형이 기본타입형인경우(또한 이 형과 parameterType형이 맞아야함)
                    오토박싱(auto-boxing)으로 자동으로 이를 wrapper객체로 생성하여 xml파일에 전달되게 되는거다.
                    그러니, int형인경우 integer타입으로 오토박싱되서 xml파일에 전달되는거다. 
                    [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]
                    +
                    아래 참조링크를 보면, 매퍼 인터페이스의 메서드의 파라미터 타입에 따라, sqlSession.select~()이 메서드에서
                    알아서 기본형 타입인경우 wrapper타입으로 생성해줘서 xml파일로 보내는것같다.
                    [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]
                4. 그리고 wrapper 타입은 getter메서드가 존재하지 않는다.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                    [참조링크 : ]                    
                5.그것도 정리해야해, sqlyog로 insert해서 int형타입에 3이나 '3'을 넣어도들어갔는데, 여기서도 이게 #{}와 ${}둘다 where에서 반영이됬던게 같은 방식인가
                    이것도 정리해야해
                    [ㅁ]  
            1-2.타입이 String형인경우
                1.ㅁ
                    [참조링크 : ]
                2.String형도 getter메서드가 존재하지 않는걸로 알고있다.
                    [참조링크 : ]       
            1-3.타입이 Dto형인경우
                ㅁ
                [참조링크 : ]      
        (3-3).그 외의 update,delete,insert 부분에 대해서도 같을것이라 보는데 그래도 직접 해봐야지 아니면 찾아보거나.
            ㅁ
            [참조링크 : ]    
        [추가사항]
            1.parameterType의 별칭은 기존의 resultType의 별칭 사용을 위한 설정의 값을 그대로 같이 쓰는것같다.
                그렇기에, DTO의 경우는 따로 별칭 설정을 하지 않았다면 패키지부터 모든 경로를 적어주어야 한다.
                [참조링크 : https://wondongho.tistory.com/72] / 별칭설정 후에 resultType과 parameterType에 사용할 수 있다.
                [참조링크 : https://babolsk.tistory.com/995] / parameterType의 별칭이라 적었는데 resultType과 같은것같다. 
            2.parameterType은 select,update,insert,delete에 모두 공통으로 쓰이는 기능이다.
                ㅁ@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                [참조링크 : ]     
                [참조문헌 : 스프링부트 시작하기 ~pg ~pg]    이거 다시 정리
                +
                그럼 이 parameterTpye부분을 위에 공통부분으로 옮겨야 할것같은데     
                +
                스프링부트 초록책을 봐도 그렇고 아래링크를 봐도 그렇고, insert,update,select,delete는 모두 parameterType 속성을 갖고있다.
                https://sjh836.tistory.com/128 
.
@@@@@@@@@여기다가, 0.sqlSession.~()메서드 실행하고 1.xml이해 2.마이바티스설정 3.데이터베이스로보냄에 대한 내용도 파일이름에 추가. + parameterType정리와 ${},#{}정리 + 메서드파라미터값의 전달과정과 xml파일해석, parameterType 그리고 CDATA방식의 이해
ㅁ
추가로, 쿼리문에서 숫자, '숫자' 에 대한내용도 정리해야한다. + 
.
xml파서의 의미 + CDATA에 대한 내용 + 동적쿼리 <if>의 개념과사용법 + gt,lt그리고 &gt;,&lt; 내용 + wrapper객체 get메서드 없음 +  
.
.
1-1.<select>에 대하여
    주로 사용하는 형식 : <select id="메서드명" parameterType="값" resultType="값">
    resultMap은 위에 설명되어 있으니 제외하고, 주로 사용되는 속성은 id, parameterType,resultType이다.
    [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]   
    [참조링크 : https://sjh836.tistory.com/128]
        {1}.<select>는 말 그대로 쿼리문을 작성하는데 있어서, select 쿼리문을 사용하는곳에 쓴다.
            [참조링크 : https://sjh836.tistory.com/128]   
            [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]   
        {2}.id는 필수속성으로 유일한 id값을 적어야 하는데, 이는 해당 namespace에 속하는
            매퍼인터페이스의 메서드명과 동일하게 적어주어야 한다.
            [참조링크 : https://bigstupid.tistory.com/23]   
            [참조링크 : https://linux.systemv.pe.kr/mybatis%EC%97%90-dao-%EC%99%80-mapper/]   
            [참조문헌 : 스프링부트 시작하기 초록책 69pg]  
        {3}.resultType
            여기있는 resultType에 대해서는 Map이나 arraylist, list 그리고 string, int배열에 관해서는 모두 배제하고
            DTO와 int, String형에 대해서만 고려하고 글을 작성하겠다. 나머지 것들에 대해서는 필요하면 다시 보도록 하자.
                1.이 resultType에는 사용하려는 클래스의 패키지명을 포함한 클래스명을 전체 모두 적어주거나, 아니면
                    별칭(alias)을 적어주어야 한다. 보통 DTO는 전체 다 적어주고, String같은것도 java.lang.String처럼
                    적어주어야하나, 일부 자주 이용하는 형태에 대해서는 미리 별칭이 정의되어 있어 string만 적어주어도 된다.
                    또한, 원시형자료형(primitive type)인 int는 기본자료형으로 클래스형은 없는것같으나 이도 별칭이 따로 정해져있다.
                    int나 integer는 별칭만 쓰는것같고, 이 int의 전체경로를 알 필요가 있으면 그때 다시 보도록 하자.
                    [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95] / resultType에 패키지를 포함한 전체 클래스이름 혹은 별칭을 적어준다.  
                    [참조링크 : https://aljjabaegi.tistory.com/457] / resultType에 패키지포함 클래스명이나 별칭적기
                    [참조링크 : https://araikuma.tistory.com/475] / 일부 자주 이용하는 형태는 별칭이 정리되어있음
                    +
                    DTO도 따로 별칭을 등록하는 방법도 있긴한데, 그건 나중에 필요할시 찾아보자.
                2..resultType은 우선, 매퍼 인터페이스의 메서드의 반환형과 호환이 가능한지(int,string,DTO)를 먼저 체크한다. 즉,
                    만약 인터페이스의 메서드 반환형과 다르다면, 에러(익셉션)를 발생한다. 하지만, resultType이 주는 기능은 이것이 다인것같다.
                    그 외에 기능은 따로없으며, 나머지는 다른곳에서 모두 처리한다. 만약 더 알아야 할 부분이 있다면 다시 보도록 하자.
                    [직접해봄]
                3.여기서는 resultType을 쓰는것에, DTO, int, String형만 고민 하기로 하자. map에 관해서는 요새 사용하지 않는다고 한다.
                    또한, 그 외에 것들의 타입들도 필요하면 다시보도록 하자. 제일 많이쓰이는 부분은 DTO이다.
                    [참조문헌 : 스프링부트 시작하기 61pg] / 여기서도 map은 요새 잘 사용하지 않는다 한다.  
                4.int,string 배열의 사용은 나중에 필요할시 따로 보기로 하고(찾아보니 이 배열 잘 안쓰는듯하다. + 배열을써도 아마 매퍼 인터페이스의 메서드 반환형
                    에 적용해서 사용하는것일꺼다.), resultType이 int나 String일때도, 따로 이를 resultType으로 쓰기보다는 dto를 위주로 사용하기로 하자. 
                    dto로 처리시 camelcasesnakecase 가 추가로 붙어져서 dto파일에 맵핑되는건데, 그렇게 큰차이는 없는것으로 보인다.(camelcasesnakecase가 문제시
                    이를 빼면된다.) 또한, 딱히 찾아봐도 int,string으로 써야한다는 문구도 없다. 필요하면 다시 정리하도록 하자.
                    [직접해봄]    
            [추가사항]  
                기본적으로 여기서 짚고 넘어가야할 부분이 있는데, resultType이 DTO, String, int일때와 매퍼 인터페이스를 마이바티스로 구현한 클래스의
                @Override된 메서드의 반환형태, 그리고 이 메서드 안에서 sqlSession으로 selectOne혹은 selectList그리고 selectMap과의 과정을 이해해야 한다.
                우선적으로 selectMap에 대한 내용은 빼도록 하겠다. 아마 이것은 resultType이 Map과 관련된 형태일때 쓰이는것같다.
                    (1).resultType이 DTO, int, String인 경우 그냥 이를 매퍼 인터페이스의 해당하는 메서드의 반환형과 일치하는지 일치하지 않으면
                        익셉션을 발생시키는지의 여부만 따지는 거다. 그러고는 그냥 데이터베이스에서 반환되는 값을 가져오기만 한다.
                        물론, resulltType이 DTO이고 매퍼인터페이스의 메서드의 반환형이 DTO 혹은 List<DTO>인경우 상관없으며, resultType이 int이건, _int이건
                        매퍼인터페이스의 메서드의 반환형이 int이건 Integer이건 상관없는것같다.
                        [직접해봄] / resultType이 int,_int이건 매퍼인터페이스의 메서드의 반환형이 int,Integer이건
                    (2).실제로 매퍼 인터페이스의 메서드의 반환형이 list<DTO>형태이면 매퍼 인터페이스를 구현한 클래스의 오버라이드한 메서드에서 
                        sqlSession.selectList로 값을 받아오는데(이 selectList된것도 반환형이 List<>여서지 resultType에서 정한게 아니다. 즉, 매퍼 인터페이스의
                        반환형이 List<DTO>이냐 <DTO>이냐에 따라 데이터베이스에서 반환하는 개체를 맵핑시키는거지 resultType은 아무 관련이 없는듯하다.) 이 
                        sqlSession.selectList 메서드 안에서 데이터베이스에서 반환되는 값을 list<DTO>형에 맞춰서 값을 매칭시켜서 sqlSession.selectList의
                        반환값으로 반환하게 된다.
                        [참조링크 : https://bigfat.tistory.com/95] / 여기에 Override한 메서드로 selectList등이 나와있다.
                        +
                            {1}.매퍼 인터페이스 반환형이 List<DTO>인 경우 만약 반환되는 개체가 0개인경우 아래 추가사항에 적어놨지만, 데이터베이스에서는 null을 반환하지만,
                                sqlSession.selectList에서는 List<DTO>형의 빈 배열객체로 맵핑이되어 반환값을 반환한다. 즉, List<DTO>의 각 요소들이 null 상태인것같다. 더 자세한건 아래 요약정리3을 보고,
                                참조자료형은 기본값이 null이라고 한다.(String이나 DTO형이나)
                                [참조링크 : https://bigfat.tistory.com/95] / 여기는 dao이지만, 매퍼인터페이스를 구현한 클래스도 이와 같을것으로 본다.
                                [참조문헌 : 자바책 195pg] / 여기서 보면, 참조자료형(Company형)이 아무값도 입력받지 못하면 null이라고 나와있다.
                                [참조링크 : https://linuxism.ustd.ip.or.kr/94] / 참조형 변수의 기본값은 null
                                [참조링크 : https://colossus-java-practice.tistory.com/9] / String형의 기본값은 null
                            {2}.매퍼 인터페이스 반환형이 List<DTO>인 경우 만약 반환되는 개체가 1개인경우 그대로 매퍼인터페이스를 구현한 클래스의 메서드가 그 sqlSessionList()메서드
                                안에서 데이터베이스에서 받아온 값 해당 1개의 arrayList<DTO>형태로 반환해주는것으로 알고있다. 이는 마이바티스에서 자동매핑해주는것으로 매퍼 인터페이스의 메서드의
                                반환형이 DTO이거나 List<DTO>인경우에만 해주는것으로 알고 있다. 
                                [직접해봄]
                            {3}.마지막으로, 매퍼 인터페이스의 반환형이 List<DTO>인 경우 만약 반환되는 개체가 2개 이상인 경우 그대로 매퍼인터페이스를 구현한 클래스의 메서드가
                                그 sqlSessionList()메서드  안에서 데이터베이스에서 받아온 값 해당 2개 이상의 arrayList<DTO>형태로 반환해주는것으로 알고있다. 이는 마이바티스에서 자동매핑해주는것으로 매퍼 인터페이스의 메서드의
                                반환형이 DTO이거나 List<DTO>인경우에만 해주는것으로 알고 있다.
                                [직접해봄]                          
                        +
                        list<>는 인터페이스다. 실제로는 이를 구현한 arrayList등을 사용하여 마이바티스에서는 값을 매칭하고 반환하는것같다. 그리하여, 이것또한
                        메서드의 반환형은 인터페이스형인데 반환되는 값의 형은 이 인터페이스를 구현한 클래스의 형이다. 이 부분도 알아야할 필요가
                        있다면 다시 자세히 보도록 하자. 아래의 참조링크도 list 인터페이스 참조자료형에 arrayList형을 넣는다.
                        [참조링크 : https://woo-yaa.tistory.com/16]   
                        [참조링크 : https://solbel.tistory.com/253]
                        +
                        그리고, mybatis.configuration.map-underscore-to-camel-case=true 가 쓰여서 dto의 camel-case와 데이터베이스의 snake표기법이
                        서로 매칭시켜주는 역활도 이 sqlSession.selectList 혹은 sqlSession.selectOne메서드에서 list<DTO>형 혹은 DTO형에 맞게 값을 매칭시켜줄때
                        작동하는것으로 알고 있다.
                        [직접해봄]
                    (3).이번에는 매퍼 인터페이스의 메서드의 반환형이 DTO형태라면 매퍼 인터페이스를 구현한 클래스의 오버라이드한 메서드에서
                        sqlSession.selectOne로 값을 받아오는데 이 sqlSession.selectOne안에서 데이터베이스에서 반환되는 값을 DTO형에 맞춰서
                        값을 매칭시켜서 sqlSession.selectOne의 반환값으로 반환하게 된다.
                        [참조링크 : https://bigfat.tistory.com/95] / 여기에 Override한 메서드로 selectOne 등이 나와있다.
                        +
                            {1}.매퍼 인터페이스 반환형이 DTO인 경우 만약 반환되는 개체가 0개인경우 그대로 매퍼 인터페이스를 구현한 클래스의 메서드가 그 sqlSession.selectOne()메서드
                                안에서 데이터베이스에서는 반환할 개체가 없으니 null을 반환하게 되어 받아온 null을 BoardDto boardDto인경우 sqlSession.selectList에서
                                실제로, null을 그대로 반환하던지 아니면 DTO형이되 값이 null인것을 반환하던지 할것이다. 그 둘의 차이는 없다. 더 자세한 것은 아래 요약정리3을 보자.
                                [참조링크 : https://bigfat.tistory.com/95]
                            {2}.매퍼 인터페이스 반환형이 DTO인 경우 만약 반환되는 개체가 1개인경우 그대로 매퍼 인터페이스를 구현한 클래스의 메서드가 그 sqlSession.selectOne()메서드
                                안에서 데이터베이스에서 받아온 1개 개체의 값들은 DTO형태에 맞게 맵핑시킨다음에 반환값으로 해당 맵핑된 DTO를 반환하게 된다.
                                [참조링크 : https://bigfat.tistory.com/95]
                            {3}.매퍼 인터페이스 반환형이 DTO인 경우 만약 반환되는 개체가 2개 이상인경우 그대로 매퍼 인터페이스를 구현한 클래스의 메서드가 그 sqlSession.selectOne()메서드
                                안에서 데이터베이스에서 받아온 2개 이상의 개체의 값들은 DTO형태로는 맞출수가 없으니 이 부분에서 익셉션이 발생하는것같다.
                                [참조링크 : https://bigfat.tistory.com/95]                                   
                        +
                        그리고, 위와 마찬가지로 mybatis.configuration.map-underscore-to-camel-case=true 가 쓰여서 dto의 camel-case와 데이터베이스의 snake표기법이
                        서로 매칭시켜주는 역활도 이 sqlSession.selectOne메서드에서 DTO 형에 맞게 값을 매칭시켜줄때 작동하는것으로 알고 있다.
                        [직접해봄]
                    (4).이번에는 매퍼 인터페이스의 메서드의 반환형이 String형태라면 매퍼 인터페이스를 구현한 클래스의 오버라이드한 메서드에서
                        sqlSession.selectOne로 값을 받아오는데 이 sqlSession.selectOne안에서 데이터베이스에서 반환되는 값을 그냥 있는 그대로
                        반환하게 된다. 나머지 컨트롤러나 Service, ServiceImpl 그리고 매퍼 인터페이스의 메서드의 반환형도 String으로 써서,
                        컨트롤러에서 String list = boardService.selectBoardList()의 형태로 값을 받아서 Model.addAttribut("list",list)로 똑같이
                        사용했었다. 사용방법들이 잘 나오지 않아 이렇게만 사용했는데, 나중에 진짜 사용하게 될시 아니면 필요할시에 더 정확하게 찾아보자.
                        [직접해봄]
                        +
                            {1}.만약 데이터에서 반환되는 개체가(당연히 개체가 반환되더라도 개체에서 반환되는 값은 1개다.) 0개 인경우, 데이터베이스에서는 값이 없을경우,
                                null을 반환하고 컨트롤러에서는 결국 String list = boardService.selectBoardList()가 String list = null;이 되게되어,
                                해당 list 변수에는 null 값이 들어가게 된다. 또한, String형의 경우 아무값도 초기화하지 않으면 기본값이 null이고 null값을 받을 수 있다.
                                [직접해봄]   
                                [참조문헌 : 자바책 195pg] / 여기서 보면, 참조자료형(Company형)이 아무값도 입력받지 못하면 null이라고 나와있다.
                                [참조링크 : https://linuxism.ustd.ip.or.kr/94] / 참조형 변수의 기본값은 null
                                [참조링크 : https://colossus-java-practice.tistory.com/9] / String형의 기본값은 null                                
                            {2}.데이터베이스에서 반환되는 값이 1개인 경우, 데이터베이스에서 반환되는 값을 그대로 반환하게 되어,
                                String list = 반환된값 으로 작용하게 되어 그대로 list에 값이 들어가게 된다.
                                [직접해봄]   
                            {3}.데이터베이스에서 반환되는 개체가 2개인 경우, 데이터베이스에서 반환되는 값을 우선은 받는데, sqlSession.selectOne메서드에서
                                둘중에 어느 값을 반환해야 할지 몰라서 익셉션이 발생하는 것으로 알고 있다.
                                [직접해봄]   
                                [참조링크 : https://bigfat.tistory.com/95]                                
                    (5).마지막으로 resultType에서 int와 _int를 쓰는경우를 정리해 보겠다. 우선,
                        resultType에서 별칭int는 실제 integer형을 의미하고 _int별칭은 실제 int형을 의미한다.
                        또한, resultType은 매퍼 인터페이스의 메서드의 반환형과 비교하여 다를경우 익셉션을 발생시킨다 얘기하였는데, 여기서는 
                        resultType이 int이건 _int이건 매퍼 인터페이스의 메서드 반환형이 int이건 Integer이건 예외체크에는 상관없는듯 하다.
                        즉, 매퍼 인터페이스의 메서드 반환형이 int이고 resultType이 int이며, 매퍼 인터페이스의 메서드 반환형이 Integer이고 resultType이 _int일때
                        잘 작동하였다.
                        [직접해봄]
                        +
                        resultType에서 별칭 int를 쓰건 _int를 쓰건 둘중 어느것을 쓰는것은 상관이 없으나 매퍼인터페이스의 메서드 반환형이 
                        무엇이냐는 의미가 있다. 아래의 것들은 모두 resultType이 int이건 _int이건 똑같이 작용하는거다.
                            [참고링크 : https://fabxoe.tistory.com/143] / 마이바티스는 resultType이 int(Integer형)이건 _int(int형)이건 같게처리한다. 또한, resultType이 int이건 _int상관없이 매퍼 인터페이스의 메서드 반환형이 Integer이기만 하면 null값을 받을 수 있다.
                            {1}.우선, 매퍼 인터페이스의 메서드 반환형이 Integer인 경우를 보겠다.
                                (1-1).반환되는 개체가 없어 값이 0개인경우
                                    이 경우는, 아래 요약정리3에서 보듯이 sqlSession.selectOne에서 null값을 반환하게 된다. 그리고, 매퍼 인터페이스의 반환형이 Integer이기
                                    때문에, 이를 받을 수 있어, 컨트롤러의 Integer list의 list가 null값을 가질 수 있게되어 오류가 발생하진않는다.
                                    [참조링크 : https://bigfat.tistory.com/95]
                                (1-2).반환되는 값이 1개인경우
                                    이 경우는, sqlSession.selectOne메서드에서 Integer형이면서 해당 데이터베이스에서 반환되는 값을 가진 Integer형을
                                    만들어서 반환하는것같다.(자바 책에서 보듯이 Integer형 변수에 바로 정수값을 넣을수는 없다.) 그리고나서, 머스테치에서
                                    {{list}}로 쓸때도, 알아서 Integer형 변수에서 값을꺼내는 메서드로 해당 정수값을 꺼내는것같다.(실제로 바로 쓸 수 없기때문)
                                    [직접해봄]   
                                    [참조문헌 : 자바책 375~377pg]   
                                {1-3}.반환되는 값이 2개 이상인경우  
                                    이 경우는, sqlSession.selectOne메서드에서 Integer형이면서 해당 데이터베이스에서 반환되는 값을 가진 Integer형을   
                                    만들어서 반환해야 하는데, 값이 2개이상이니 예외가 발생하게 되는거다.                       
                                    [직접해봄]
                            {2}.다음은, 매퍼 인터페이스의 메서드 반환형이 int인 경우를 보겠다.
                                {2-1}.반환되는 값이 0개인경우
                                    이 경우에는, 아래 요약정리3에서 보듯이 sqlSession.selectOne에서 null값을 반환하게 된다. 그러나, 매퍼 인터페이스의 반환형이 Int이기
                                    때문에, 이는 바로 예외를 발생시키게 된다.
                                    [직접해봄]
                                {2-2}.반환되는 값이 1개인경우
                                    이 경우는, sqlSession.selectOne메서드에서 그대로 데이터베이스에서 받아온 값을 그대로 반환값으로 쓰게되서
                                    해당 값을 매퍼 인터페이스의 메서드의 반환값으로 쓰게 되서 적용하게 된다.
                                    [직접해봄]
                                {2-3}.반환되는 값이 2개 이상인경우    
                                    이 경우는, sqlSession.selectOne메서드에서 받아온 값을 그대로 반환하게 되있는데, 
                                    값이 2개 이상이니 예외가 발생하게 되는거다.
                                    [직접해봄]                                                               
                 [요약정리 & 추가정리]
                    1.필요한 부분을 정리해보면, 1.매퍼 인터페이스가 있고, 2.이를 마이바티스로 구현한 클래스가 있고, 3.이 구현한 클래스안에 @Override한 메서드가 있고
                        해당 @Override한 메서드 안에는 또 반환되는값이 sqlSession.select~() 형태로 해당 메서드에서 반환하는 값으로 @Override메서드의 반환되는 값으로 쓰이는거다.
                        그러면, 쿼리문을 이용한 resultType으로 인해 받아오는 값들은 그대로 거기에 있고 그다음 필요할시에 sqlSession.select~()메서드에서 맵핑을 해서 나오거나
                        (DTO, List<DTO>의 경우) 아니면 그냥 값(String,int)을 반환하여 @Override한 메서드의 반환값으로 쓰이게 되는 구조다.
                        [참조링크 : https://bigfat.tistory.com/95]
                    2.resultType의 별칭은 아래 참조링크에 정리되어 있다.
                        [참조링크 : https://java119.tistory.com/45]   
                        [참조링크 : http://www.devkuma.com/books/pages/740]   
                        [참조링크 : https://araikuma.tistory.com/475]  
                    3.직접 resultType이 int, _int, string, DTO일때 상관없이 모두 데이터베이스에서 반환할 값이 없을때 
                        null이 반환되어 데이터베이스에서 받아온 값이 null이 되게 된다.
                        [참조링크 : https://tomining.tistory.com/152] / 데이터베이스에서 select쿼리문으로 반환할 값이 없으면 null을 반환한다. 이는 resultType이 int인것외에도 항상 그러는듯하다.  
                        [참조링크 : https://araikuma.tistory.com/475] / 검색결과값이 하나도 없는 경우 데이터베이스에서는 null을 반환한다.
                        문제는 그 다음인데, 매퍼 인터페이스의 메서드의 반환형에 따라서 sqlSession.selectOne이나 sqlSession.selectList메서드에서 다르게 맵핑하여
                        반환값을 반환한다는거다. 
                            (1).매퍼 인터페이스의 메서드의 반환형이 List<DTO>일때
                                만약 데이터베이스에서 반환되는 개체가 없어서, null이 반환된경우에 sqlSession.selectList 메서드에서는 그냥 null값을
                                반환하는게 아니라, List<DTO>형의 빈 배열을 반환값으로 낸다.
                                실제로,
                                List<BoardDetailDto> list = boardDetailService.selectBoardDetailList();
                                        if(list.size()==0){
                                            System.out.println("배열이 비어있다.");
                                        }
                                와 같이, 컨트롤러에 적용했더니, 해당 출력문이 출력됬었다.
                                [직접해봄]
                                +
                                처음에는 
                                serviceImpl에서 
                                if(boardDetailMapper.selectBoardDetailList()==null){
                                    System.out.println("반환값이 null이다.");
                                }
                                이렇게 그냥 List<DTO>도 sqlSession.selectList에서 null값만 반환되는줄알고 이렇게 했는데 막상
                                실행해보니 저 출력문이 나타나지 않았다. 어느 글에서 봤는데 List<DTO> list==null인 경우는 아예 DTO도 조차
                                선언되지 않은거라고 했다. 그래서 null이 성립이 안되었던것같다.(이 부분 필요시 더 자세히 보기)
                                또한, 애초에 list<DTO> list==null인 상태면, list.isEmpty()나 list.size()조차도 익셉션을 발생시킨다한다.
                                [참조링크 : https://ssamdu.tistory.com/9] / List<DTO> list가 null이면 .size()나 .isEmpty()같은 메서드 예외발생시킴
                                [직접해봄]
                            (2).매퍼 인터페이스의 메서드의 반환형이 List<DTO>일때
                                이 경우에는 아래의 출력문이 그대로 출력되었다.(데이터베이스에서 반환되는 개체가 없었을때)
                                serviceImpl에서 
                                if(boardDetailMapper.selectBoardDetailList()==null){
                                    System.out.println("반환값이 null이다.");
                                }
                                이 경우에는 실제로 sqlSession.selectOne메서드에서 null이 반환된건지 아니면 null값이 들어있는
                                DTO형이 반환된것인지는 모르나 그 부분을 크게 중요할것 같지 않다.
                                [직접해봄]
                            (3).매퍼 인터페이스의 메서드의 반환형이 String일때
                                이 경우에는 아래의 출력문이 그대로 출력되었다.(데이터베이스에서 반환되는 개체가 없었을때)
                                serviceImpl에서 
                                if(boardDetailMapper.selectBoardDetailList()==null){
                                    System.out.println("반환값이 null이다.");
                                }
                                이 경우에는 실제로 sqlSession.selectOne메서드에서 null이 데이터베이스에서 받아온 값 그대로 반환한것같다. 
                                [직접해봄]                                   
                            (4).매퍼 인터페이스의 메서드의 반환형이 Integer일때
                                이 경우에는 아래의 출력문이 그대로 출력되었다.(데이터베이스에서 반환되는 개체가 없었을때)
                                serviceImpl에서 
                                if(boardDetailMapper.selectBoardDetailList()==null){
                                    System.out.println("반환값이 null이다.");
                                }
                                이 경우에는 실제로 sqlSession.selectOne메서드에서 null이 데이터베이스에서 받아온 값 그대로 반환한것같다. 
                                [직접해봄]       
                            (5).매퍼 인터페이스의 메서드의 반환형이 int일때
                                이 경우는 데이터베이스에서 반환된 null을 sqlSession.selectOne에서 그대로 값으로 반환하는데,
                                이 경우에는 매퍼 인터페이스의 메서드의 반환형이 int이기 때문에 이를 구현한 클래스의 @Override의
                                메서드의 반환형도 int여서 sqlSession.selectOne에서 반환한 null값때문에 오류를 일으키는것같다.
                                [직접해봄]  
                    4.String과 int형 그리고 Integer형은 나중에 실제 사용하게 되면 그때 더 자세하게 알아보도록하자.
                        위의 사용법들은 DTO와 list<DTO>기반으로 내가 직접한거라 예시를 찾아볼 필요가 있다.
                    5.이 resultType에 대한 속성은 <insert>,<update>,<delete>,<select>의 태그중에 select에만 있는 속성으로 알고있다.
                        아래 참조링크에도 그렇게 나오고, 스프링부트 시작하기 초록책에도 <select>에만 resultType이 나와있다.
                        아래 (4).의 추가사항에도 나와있다.
                        [참조문헌 : 스프링부트 시작하기 초록책]   
                        [참조링크 : https://sjh836.tistory.com/128]   
        (4).resultMap에 대해서 잠깐 보고가겠다.
            {1}.resultMap은 resultType대신에 쓸 수 있는것으로, 보니까 <select>문에 쓰이고 그 외에
                <insert>, <delete>, <update>문에는 쓰이지 않는것 같다. 만약에 쓰이게 된다면 다시와서
                다시 정리해보도록하자.
                [참조링크 : https://m.blog.naver.com/10hsb04/221718179519]
            {2}.간단하게, 기능을 설명하자면 마이바티스는 구현된 매퍼 클래스에서 값을 반환하기 전에 알아서
                List<dto>, dto등을(String이나 int형의 배열은 제외하자. 그건 사용하게 되면 그때보기) 데이터베이스에서
                갖고온값과 매핑을 시켜주는데, resultType은 DTo클래스가 갖고있는 setter메서드로 자동 맵핑되고, resultMap방식은
                일일히 직접 명시해줘서 맵핑을 해주는 방식이다. 또한, DTO방식밖에 모르는데,
                만약에 사용해야 한다면 아래 링크로 더 자세히 알아보자. 
                [참조링크 : https://dorongdogfoot.tistory.com/124]   
                [참조링크 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]   
                [참조링크 : https://reference-m1.tistory.com/178]
            {3}.아래 참조링크를 보면, resultMap에서는 서로 맵핑해주려는 필드값들이 대소문자를 구분했었는데,
                resultType은 대소문자를 구분하지 않았다고 한다. 어차피 카멜 표기법과 스네이크 표기법을 통합해주는 방식을
                사용하여 문제는 없지만 이렇다는것만 알고 넘어가자.
                [참조링크 : https://m.blog.naver.com/10hsb04/221718179519]   
            {4}.그러나, 주로 resultType을 사용하고 resultMap은 잘 사용하지 않는거로 알고있다.
                만약에 나중에 사용해야 하는 경우가 나온다면 어떤 경우인지 알고 다시 정리하도록 하자.   
        [추가사항]
            resultType 혹은 resultMap은 <select>문에만 쓰이는것으로 <insert>, <delete>, <update>에는 쓰이지 않는다고 한다.
                만약에 이를 다시 봐야하는 상황이 오면 다시 정리하도록 하자. 위의 요약정리&추가정리의 5.에도 정리해 놓았다.
                [참조링크 : https://m.blog.naver.com/10hsb04/221718179519]     
.
.
.
            아니 잠깐만, string이건 integer이건 아무값도 없는경우 null값 반환받을 거고 그 list변수를 머스테치에 {{list}}라고 썻더니 에러나는데??????????????
            @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 머야 {{^list}}같은거는 그냥 아예 동작안하고 왜 이거는 ㅎ익셉션 발생시키는거지? 아니 그거 찾아보자. 그 머냐 어디에 {{변수}}에서
            변수값이 없으면 아예 표시안한다 했는데 시팔.
            +
                .
                아니 그리고 int는 별칭에서 integer라며, 근데 시팔 스프링부트 초록책은 파라미터타입에 int라 했는데?
.
.
.
2-1.<insert>에 대하여
.
.
.
2-2.
.
.
.
3-1.<update>에 대하여
.
.
.
3-1.
.
.
.
4-1.<delete>에 대하여
.
.
.
4-2.
.
.
.